#!/bin/sh
# xbalog06 Michal Balogh
# 10.3.2023

export POSIXLY_CORRECT=yes
export LC_ALL=C

DATETIME=$(date +%Y-%m-%d_%H-%M-%S)


#------functions section---------------------------------------------------------------

# vypise help message
print_help() {
  echo ""
  echo "Usage: mole -h"
  echo "       mole [-g GROUP] FILE"
  echo "       mole [-m] [FILTERS] [DIRECTORY]"
  echo "       mole list [FILTERS] [DIRECTORY]"
  echo ""
  echo "Description:"
  echo ""
  echo "  -h: Display this help message."
  echo "  -g GROUP: Assign the opened file to the specified group."
  echo "  -m: Select the most frequently opened file instead of the last opened one."
  echo ""
  echo "  list: List the files that were opened with mole."
  echo ""
  echo "  FILE: Open the specified file."
  echo "  FILTERS: Apply filters to the list"
  echo "  DIRECTORY: Select the directory to search in. If not directory is not specified, current directory will be used."
  echo ""
  echo "FILTERS:"
  echo "  -g GROUP1[,GROUP2[,...]] Only consider files whose execution falls within at least one of the specified groups."
  echo "  -a DATE Only consider files opened or edited before this date. Format: YYYY-MM-DD."
  echo "  -b DATE Only consider files opened or edited after this date. Format: YYYY-MM-DD."
  echo ""
}

# vyberie nastaveny editor a otvori subor FILE
# priortine ten, ktory je ulozeny v premennej EDITOR
# ak EDITOR nie je nastaveny, otvori subor pomocou editora nastaveneho v premennej VISUAL
# ak nie je nastavena ani premenna VISUAL, pouzije sa prikaz vi
open_editor() {
  if [ "$EDITOR" ]; then
    "$EDITOR" "$FILE"
  elif [ "$VISUAL" ]; then
    "$VISUAL" "$FILE"
  else
    vi "$FILE"
  fi
}

# mole list [FILTERS] [DIRECTORY]
# zobrazi zoznam suborov ktore vyhovuju aplikovanym filtrom
list(){
  # vyfiltruje data
  filter_data
  # ak filtrom nevyhovuju ziadne subory, nevypise nic a ukonci program
  if [ -z "$FILTERED" ]; then
    exit 1
  fi
  # z dat ktore vyhovuju filtrom vyberie len tie, ktore su z daneho suboru
  # z cesty ulozenej na $6 si pomocou prikazu sub(/\/[^\/]*$/, "", $6) vyberie len adresar a porovna ho z adresarom ktory bol zadany
  # ak sa zhoduju, ulozi ho do filtrovanych dat
  if [ -z "$RECURSIVE" ]; then
    FILTERED=$(echo "$FILTERED" | awk -v dir="$DIR" -F ';' '{sub(/\/[^\/]*$/, "", $6); if ($6 == dir || $6"/" == dir) print }')
  fi
  # zoradi najdene subory podla stlpca $5 (nazov suboru) a potom podla stlpca $3 (skupina), zoradi ich lexikograficky 
  # -dfu zoradenie podla abecedy, case-insensitive, unique
  SORTED=$(echo "$FILTERED" | sort -dfu -k5 -k3)

  # if - ak nebola zadana grupa pri jednom otvoreni, ale pri druhom ano, odstrani '-' a nahradi ho skupinou
  # else - pospaja rovnake subory s roznymi skupinami do jedenho a skupiny oddeli ciarkami
  # vykonava sa dovtedy, dokym nie je na prvom riadku (NR > 1), ak ano, do SORTED este ulozi prvy riadok
  SORTED=$(echo "$SORTED" | awk '{ split($0, cols, " "); 
    if (cols[5] == prev_col5) {
      if (prev_col3 == "-"){prev_col3 = cols[3]} 
      else {prev_col3 = prev_col3 "," cols[3]}
    } 
    else {
      if (NR > 1) { print prev_col1, prev_col2, prev_col3, prev_col4, prev_col5 }
      prev_col1 = cols[1]
      prev_col2 = cols[2]
      prev_col3 = cols[3]
      prev_col4 = cols[4]
      prev_col5 = cols[5]
      }
    }
    END { print prev_col1, prev_col2, prev_col3, prev_col4, prev_col5 }')

  # najde najdlhsi nazov suboru kvoli zarovnaniu skupin
  LONGESTNAME=$(echo "$FILTERED" | awk -F ' ' '{ if (length($5) > max) max=length($5) } END { print max }')
  LONGESTNAME=$((LONGESTNAME+1)) # +1 minimalna medzera
  # vypisanie vystupu aj s odsadenim skupin
  echo "$SORTED" | awk -F ' ' '{printf "%-'$LONGESTNAME's %s\n", $5":", $3}'

  exit 0
}

# ziska nazov adresaru s ktorym chceme pracovat
# ak nebol zadany subor (FILE), ziska nazov aktualneho adresara
getdir(){
  if [ -z "$FILE" ]; then
    DIR=$(basename "$(realpath .)")
  else
    DIR=$(basename "$(dirname "$(realpath "$FILE")")")
  fi
}

# zapis dat do suboru daneho premennou MOLE_RC
# data su oddelene bodkociarkou ';'
# ak nebola zadana grupa, zapise namiesto toho pomlcku '-'
log_mole_rc(){ 
  getdir
  if [ -z "$GROUP" ];then
    GROUP="-"
  fi
  NAME=$(basename "$FILE")
  echo "$DATETIME;$USER;$GROUP;$DIR;$NAME;$(realpath "$FILE")" >> "$MOLE_RC"
} 



secret_log(){
  # vyfiltruje data
  filter_data
  # ak filtrom nevyhovuju ziadne subory, nevypise nic a ukonci program
  if [ -z "$FILTERED" ]; then
    exit 0
  fi
  # definuje cestu k adresaru secret-logu
  SL_PATH="/home/$USER/.mole"
  # ak neexistuje, vytvori ju
  if [ ! -d "$SL_PATH" ]; then
    mkdir "$SL_PATH"
  fi 
  # definujte nazov suboru - log_uzivatel_datumcas
  FILENAME="log_""$USER"_"$DATETIME"
  # pomocou awk vyberie a preusporiada stlpce filtrovanych dat a potom ich zoradi (abecedne, case-insensitive)
  # premenna "last_file" sleduje posledny spracovany subor
  # premenna "date" zhromazduje datumy pre aktualny subor oddelene ciarkou
  # prva podmienka if sa vykona pri zmene nazvu suboru (to znamena ze vsetky otvorenia suboru uz su zhromazdene do jedneho so vsektymi casmi)
  # druha podmienka if sa vykona pri dosiahnuti posledneho riadku suboru
  echo "$FILTERED" | awk -F ';' '{print $6 ";" $1}' \
  | sort -df \
  | awk -F ';' '
    BEGIN {last_file = ""}
    { if ($1 != last_file) {
        if (last_file != "") {
          print date
        }
        last_file = $1
        date = $1 ";"
        }
        date = date $2 ";"
      }
      END {if (last_file != "") print date}' \
  | sed 's/;$//' \
  | bzip2 -c > "$SL_PATH"/"$FILENAME".bz2
  # sed 's/;$//' odstrani koncovu bodkociarku
  # bzip2 -c ulozi data do suboru v adresari secret logu, ktory skomprimuje
}

# kontrola spravneho formatu datumu pomocou regulerneho vyrazu (4_cislice-2_cislice-2_cislice)
# pouzita vo funkcii filter_data
check_date_format() {
  if ! echo "$1" | grep -Eq '^[0-9]{4}-[0-9]{2}-[0-9]{2}$'; then
    echo "Invalid date format"
    echo "The correct format of date is YYYY-MM-DD"
    exit 1
  fi
}

# aplikuje filtry na zaznamy v subore MOLE_RC
filter_data(){
  # nacita obsah suboru MOLE_RC do premennej FILTERED
  FILTERED=$(cat "$MOLE_RC")
  #volitelny prepinac -d, ak je nastaveny, bude vyhladavat editacie bez skupiny, takze v zanzmaoch oznacene '-'
  if [ "$DEFAULT" ];then 
    GROUP="-"
  fi
  # ak je GROUP nastavena a zaroven nie je skript spusteny s funkcionalitou secret-log, vyfiltruje zaznamy ktore obsahuju skupinu/skupiny GROUP
  # rozdeli premennu GROUP skupiny ak ich je viac oddelenych ciarkov, a kazdu porovna so zaznamom v premennej FILTERED
  if [ "$GROUP" ] && [ -z "$SECRETLOG" ]; then
    FILTERED=$(echo "$FILTERED" | awk -F';' -v groups="$GROUP" '
      BEGIN {split(groups, arr, ",")}
      {for(i in arr) if($3 == arr[i]) {print; break}}')
  fi
  # prepinac -r
  if [ "$RECURSIVE" ]; then
    FILTERED=$(echo "$FILTERED" | awk -v dir="$DIR" -F ';' '{sub(/\/[^\/]*$/, "", $6); if (index($6, dir) == 1) print}')
  fi
  # filter pre funkcionalitu secret-log [DIRECTORIES]
  if [ "$SECRETLOG" ] && [ "$DIRECTORIES" ]; then
    FILTERED=$(echo "$FILTERED" | awk -F';' -v OFS=';' -v dirs="$DIRECTORIES" '
      BEGIN {split(dirs, arr, " ")}
      {
        rpath=$6
        for (i=1; i<=NF; i++) {
          sub(/\/[^\/]*$/, "", $i)
        }
      }
      {
        for (i in arr) {
          for (j=1; j<=NF; j++) {
            if ($j == arr[i]) {
              print $1,$2,$3,$4,$5,rpath
              break
            }
          }
        }
      }'
    )
  fi

  # prepinac -a
  if [ "$DATE_AFTER" ]; then
    check_date_format "$DATE_AFTER"
    # rozdeli date_time na date a time, porovna date so zadanym datumom v premennej DATE_AFTER
    FILTERED=$(echo "$FILTERED" | awk -F';' -v date="$DATE_AFTER" '{split($1, dt, "_"); if (dt[1] > date) print}')

  fi
  
  # prepinac -b
  if [ "$DATE_BEFORE" ]; then
    check_date_format "$DATE_BEFORE"
    # rozdeli date_time na date a time, porovna date so zadanym datumom v premennej DATE_BEFORE
    FILTERED=$(echo "$FILTERED" | awk -F';' -v date="$DATE_BEFORE" '{split($1, dt, "_"); if (dt[1] < date) print}')
  fi

}


open_file() {
  
  # ak zadane argumenty nevyhovovali ani jednemu suboru, skript sa ukonci s chybovym hlasenim
  if [ -z "$FILE" ]; then
    echo ERROR: Could not find file with the specified criteria
    exit 1
  fi
  
  open_editor "$(basename "$FILE")"
  # kontrola, ci sa editor neukoncil s chybovym hlasenim
  exitcode=$?
  if [ $exitcode -ne 0 ]; then
    echo ERROR: Could not open editor
    exit 1
  fi
  # zapis editacie suboru 
  log_mole_rc
}


#------code section--------------------------------------------------------------------

# kontrola ultility 'realpath'
if ! command -v realpath >/dev/null; then
  echo "Error: command realpath not found"
  exit 1
fi


# kontrola nastavenia premmenej MOLE_RC
if [ -z "$MOLE_RC" ]; then
  echo "Error: MOLE_RC is not set"
  exit 1
fi

# ak subor dany cestou MOLE_RC neexistuje, vytvori ho
if [ ! -f "$MOLE_RC" ]; then
  mkdir -p "$(dirname "$MOLE_RC")"
  touch "$MOLE_RC"
fi

#--------------------------------------------------------------------------------------

# Zaciatok parsovania argumentov

# mole list
if [ "$1" = "list" ]; then
  LIST="TRUE"
  shift
fi

# mole secret-log
if [ "$1" = "secret-log" ]; then
  SECRETLOG="TRUE"
  shift
fi

# ziskanie vsetkych prepinacov (-h, -g, -m, -a, -b)
while getopts ":hg:ma:b:dr" option; do
  case "$option" in
  h)      print_help; exit 0;;
  g)      GROUP=$OPTARG;;
  m)      MOST_USED="TRUE";;
  a)      DATE_AFTER=$OPTARG;; #YYYY-MM-DD format 
  b)      DATE_BEFORE=$OPTARG;; #YYYY-MM-DD format
  d)      DEFAULT="TRUE";; # volitelne rozsirenie -d
  r)      RECURSIVE="TRUE";; # volitelne rozsirenie -r, obmedzenia: funguje len pre mole list
  :)      echo "Error: -$OPTARG requires an argument"; exit 1;;
  *)      echo "Invalid option: -$OPTARG" >&2
          echo "Try 'mole -h' for more information."
          exit 1;;
  esac
done

shift $((OPTIND-1))

# Koniec parsovania argumentov 

#--------------------------------------------------------------------------------------

# -d a -g nemozu byt zadane sucastne, program vypise chybove hlasenie ak su zadane obidve
if [ "$GROUP" ] && [ "$DEFAULT" ]; then
  echo "Error: The -g and -d switches cannot be specified simultaneously. Please choose only one switch to use at a time."
  exit 1
fi

# funkcnost programu mole list
if [ "$LIST" ]; then
  if [ $# -eq 0 ]; then
    # pri nezadani priecinku, vyberie aktualny priecinok
    DIR=$(realpath .)  
  else 
    DIR=$1
  fi
  list
  exit 0
fi

# funkcnost programu mole secret-log
if [ "$SECRETLOG" ]; then
  # ziska vsetky postupne zadane priecinky
  while [ $# -ne 0 ]; do 
    DIRECTORIES="$DIRECTORIES $1"
    shift
  done 
  secret_log
  exit 0
fi

# aplikuje na program zadane filtry
filter_data

if [ $# -eq 0 ]; then
  # mole
  # otvori subor z aktualneho adresara
  current_dir=$(realpath .)  
else
  ARGUMENT=$(realpath "$1")
  if [ -d "$ARGUMENT" ]; then
    # mole dir
    # otvori subor z daneho adresara
    current_dir=$ARGUMENT
  else 
    # mole file
    # otvori subor specifikovany argumentom, pripadne aj so zadanou skupinou ziskanou z filter_data
    FILE=$ARGUMENT
    open_file
    exit 0
  fi
  shift
fi


# otvori v editore posledny editovany subor v tomto adresari
# data su uz vyfiltrovane aplikovanymi filtrami
if [ "$MOST_USED" ]; then
  # aplikovanie prepinaca -m
  FILTERED=$(echo "$FILTERED" | awk -v current_dir="$current_dir" -F ';' '{rpath=$6; sub(/\/[^\/]*$/, "", $6); if ($6 == current_dir) print rpath}')
  FILE=$(echo "$FILTERED" | sort | uniq -c | sort -rn | head -n 1 | awk '{print $2}' )
else
  # v $6 je ulozena 'realpath subor'
  # regulerny vyraz sub(/\/[^\/]*$/, "", $6) odstrani vsetko po poslednom '/' -> ziska cestu k suboru
  # ziskanu cestu porovna s aktualnym adresarom, ak je rovnaky, dosadi ho do last_match
  # po prejdeni celeho suboru dosadi do premennej FILE poslednu zhodu (posledny otvoreny subor)
  FILE=$(echo "$FILTERED" | awk -v current_dir="$current_dir" -F ';' '{rpath=$6; sub(/\/[^\/]*$/, "", $6); if ($6 == current_dir) {last_match=rpath}} END {print last_match}' )
fi

# ak sa nenajde ziadna zhoda, ukonci skript s chybovym hlasenim
if [ -z "$FILE" ]; then
  echo "No files were edited with mole in this directory"
  exit 1
fi

# otvori subor ktory vyhovuje aplikovanym filtrom
open_file

exit 0